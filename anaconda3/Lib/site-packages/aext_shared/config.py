import json
import os
import platform
import warnings
from enum import Enum
from typing import Dict, TypedDict, Union

import jupyterlab
import jupyterlab_server


class Heap(TypedDict):
    clientId: str


class Datadog(TypedDict):
    clientToken: str
    service: str


class FeatureFlag(TypedDict):
    clientId: str
    overrides: Dict[str, Union[str, bool]]


class Cloud(TypedDict):
    url: str
    staticContent: str


class Notebooks(TypedDict):
    url: str


class Org(TypedDict):
    url: str


class Environment(str, Enum):
    # Ignore the type errors for now. In the future, once the minimum python is >= 3.11,
    # switch this to StrEnum: https://stackoverflow.com/questions/58608361/string-based-enum-in-python
    # NOTE: these 3 envs will be deprecated
    development: str = "development"  # type: ignore
    production: str = "production"  # type: ignore
    local: str = "local"  # type: ignore

    # new definition for environments
    cloud_production: str = "cloud_production"  # type: ignore
    local_production: str = "local_production"  # type: ignore
    cloud_development: str = "cloud_development"  # type: ignore
    local_development: str = "local_development"  # type: ignore
    github_actions: str = "github_actions"  # type: ignore

    @classmethod
    def is_local(cls, env: "Environment") -> bool:
        return env in [cls.local_development, cls.local_production, cls.local]

    @classmethod
    def is_cloud(cls, env: "Environment") -> bool:
        return env in [cls.cloud_production, cls.cloud_development]


class CloudDevelopmentHosts(str, Enum):
    tulz: str = "http://tulz.pa-dev.com"
    bp: str = "http://bp.pa-dev.com"
    nucleus_latest: str = "http://nb.nucleus-latest.anacondaconnect.com"


class CloudProductionHosts(str, Enum):
    nb: str = "http://nb.anaconda.cloud"


class JupyterLab(TypedDict):
    server: str
    client: str


class OSPlatform(TypedDict):
    name: str
    system: str
    version: str
    release: str


class AssistantEnvironmentType(str, Enum):
    # Ignore the type errors for now. In the future, once the minimum python is >= 3.11,
    # switch this to StrEnum: https://stackoverflow.com/questions/58608361/string-based-enum-in-python
    # Possible values:
    # - local-dev for local development
    # - cloud-notebooks-prod for users of Anaconda Cloud
    # - cloud-notebooks-staging for users of Anaconda Cloud staging
    # - local-notebooks-dev for developing the Assistant for users of Jupyter Lab working locally
    # - local-notebooks-prod for users of Jupyter Lab working locally
    # - enterprise-notebooks-dev for developing the Assistant for users of AE5
    # - enterprise-notebooks-prod for users of AE5
    localDev: str = "local-dev"  # type: ignore
    cloudNotebooksProd: str = "cloud-notebooks-prod"  # type: ignore
    cloudNotebooksStaging: str = "cloud-notebooks-staging"  # type: ignore
    localNotebooksDev: str = "local-notebooks-dev"  # type: ignore
    localNotebooksProd: str = "local-notebooks-prod"  # type: ignore
    enterpriseNotebooksDev: str = "enterprise-notebooks-dev"  # type: ignore
    enterpriseNotebooksProd: str = "enterprise-notebooks-prod"  # type: ignore


class AssistantEnvironmentAPIUrl(str, Enum):
    # Ignore the type errors for now. In the future, once the minimum python is >= 3.11,
    # switch this to StrEnum: https://stackoverflow.com/questions/58608361/string-based-enum-in-python
    # Possible values:
    # - https://assistant.anaconda.cloud
    # - https://jupyterassistant.anacondaconnect.com
    production: str = "https://assistant.anaconda.cloud"  # type: ignore
    development: str = "https://jupyterassistant.anacondaconnect.com"  # type: ignore


class AssistantConfig(TypedDict):
    environmentType: AssistantEnvironmentType
    apiUrl: AssistantEnvironmentAPIUrl


class Config(TypedDict):
    environment: Environment
    jupyterlab: JupyterLab
    heap: Heap
    datadog: Datadog
    featureFlag: FeatureFlag
    cloud: Cloud
    notebooks: Notebooks
    org: Org
    assistant: AssistantConfig
    platform: OSPlatform


class ConfigValueFactory:
    """
    A factory for obtaining config values.

    Values can be set by environment variable with a default fallback.
    """

    def __init__(self) -> None:
        try:
            # cloud specific configuration defaults
            # This import will succeed in the cloud package because the associated file in included.
            # The file is not included in the local package and will cause an ImportError.
            # This is handled below to load local specific defaults.
            from .cloud_config_defaults import config_defaults

            if os.environ.get("DEBUG_AEXT_SHARED_LOCAL", False):
                raise ImportError
            self.defaults = config_defaults
        except ImportError:
            # local (non-cloud) configuration defaults
            self.defaults = {
                "ANACONDA_ASSISTANT_ENVIRONMENT_TYPE": "local-notebooks-prod",
                "ANACONDA_ASSISTANT_API_URL": "https://assistant.anaconda.cloud",
                "ANACONDA_CLOUD_API_URL": "https://anaconda.cloud/api",
                "ANACONDA_CLOUD_STATIC_CONTENT_URL": "https://static.anaconda.cloud/shared",
                "ANACONDA_NOTEBOOKS_URL": "https://nb.anaconda.cloud",
                "ANACONDA_ORG_API_URL": "https://notebooks.anaconda.org",
                "DEBUG_FEATURE_FLAG_OVERRIDES": json.dumps(
                    {
                        "monorepo-assistant": True,
                        "monorepo-panel": True,
                        "panel-sign-out-jupyterlab": True,
                        "share-notebook-use-projects-v2": True,
                        "sharing-show-preview": True,
                        "monorepo-share-notebooks": True,
                        "monorepo-panel-show-publish-button": False,
                        "monorepo-show-anaconda-toolbox": False,
                        "monorepo-show-project-file-status": False,
                        "monorepo-show-toolbox-code-snippets": False,
                    }
                ),
                "LOCAL": "true",
                "LOCAL_PRODUCTION": "true",
            }

    def __getitem__(self, key) -> str:
        return os.environ.get(key, self.defaults.get(key))


def get_config() -> Config:
    cvfactory = ConfigValueFactory()

    try:
        overrides = json.loads(cvfactory["DEBUG_FEATURE_FLAG_OVERRIDES"])
    except json.JSONDecodeError:
        warnings.warn("DEBUG_FEATURE_FLAG_OVERRIDES is not valid JSON. Using the default value (or empty).")
        # log a warning about the invalid environment variable
        overrides = cvfactory.defaults.get("DEBUG_FEATURE_FLAG_OVERRIDES", {})

    return Config(
        heap=Heap(clientId=cvfactory["HEAP_CLIENT_ID"]),
        datadog=Datadog(
            clientToken=cvfactory["DATADOG_CLIENT_TOKEN"],
            service=cvfactory["DATADOG_SERVICE"],
        ),
        featureFlag=FeatureFlag(
            clientId=cvfactory["LAUNCH_DARKLY_CLIENT_ID"],
            overrides=overrides,
        ),
        cloud=Cloud(
            url=cvfactory["ANACONDA_CLOUD_API_URL"],
            staticContent=cvfactory["ANACONDA_CLOUD_STATIC_CONTENT_URL"],
        ),
        notebooks=Notebooks(url=cvfactory["ANACONDA_NOTEBOOKS_URL"]),
        org=Org(url=cvfactory["ANACONDA_ORG_API_URL"]),
        environment=get_environment(cvfactory),
        environment_v2=get_environment_v2(cvfactory),
        jupyterlab=JupyterLab(server=jupyterlab_server.__version__, client=jupyterlab.__version__),
        assistant=AssistantConfig(
            environmentType=cvfactory["ANACONDA_ASSISTANT_ENVIRONMENT_TYPE"],
            apiUrl=cvfactory["ANACONDA_ASSISTANT_API_URL"],
        ),
        platform=OSPlatform(**get_os_info()),
    )


def get_environment(cvfactory: ConfigValueFactory) -> Environment:
    if bool(cvfactory["LOCAL"]):
        return Environment.local
    nb_service_site = cvfactory["ANACONDA_NOTEBOOKS_URL"]
    pythonanywhere_site = cvfactory["PYTHONANYWHERE_SITE"]
    if bool(pythonanywhere_site) and pythonanywhere_site in nb_service_site:
        return Environment.production
    return Environment.development


def get_os_info():
    return {
        "name": platform.platform(),
        "system": platform.system(),
        "version": platform.version(),
        "release": platform.release(),
    }


def get_environment_v2(cvfactory: ConfigValueFactory) -> Environment:
    """
    Determine the environment based on various flags and configuration values.

    This function attempts to infer the environment from environment variables,
    configuration values, and predefined hostnames. The following environments
    are supported in the precedence order.:

    - `github_actions`: execution in GitHub Actions
    - `local_development`: local development environment (e.g., running with `LOCAL_DEVELOPMENT` set)
    - `local_production`: local production environment (e.g., running on a server with `LOCAL_PRODUCTION` or `LOCAL` set)
    - `cloud_production`: cloud production environment (e.g., running on PythonAnywhere with a valid site ID)
    - `cloud_development`: cloud development environment (e.g., running on a PythonAnywhere development host)

    If none of these environments can be determined, a ValueError is raised.

    Args:
        cvfactory: an instance of ConfigValueFactory to retrieve configuration values from

    Returns:
        the determined Environment instance
    """

    def str_to_bool(value):
        return str(value).strip().lower() in ["1", "true", "yes"]

    is_github_actions = str_to_bool(os.getenv("GITHUB_ACTIONS", "false"))
    is_local_development = str_to_bool(os.environ.get("LOCAL_DEVELOPMENT", "false"))
    is_local_production = str_to_bool(cvfactory["LOCAL"]) or str_to_bool(os.environ.get("LOCAL_PRODUCTION", "false"))

    if is_github_actions:
        return Environment.github_actions

    if is_local_development:
        return Environment.local_development

    # local production
    if not is_local_development and is_local_production:
        return Environment.local_production

    # cloud environments
    pythonanywhere_site = cvfactory["PYTHONANYWHERE_SITE"]
    if not is_local_development and bool(pythonanywhere_site):
        # cloud production
        for host in CloudProductionHosts:
            if pythonanywhere_site == host.value:
                return Environment.cloud_production

        # cloud development
        for host in CloudDevelopmentHosts:
            if pythonanywhere_site == host.value:
                return Environment.cloud_development

    warnings.warn("No valid environment flag is defined.")
    return Environment.cloud_production
