from jupyter_server.services.contents.largefilemanager import AsyncLargeFileManager
from tornado import web

from aext_shared.consts import ANACONDA_PROJECTS_DIR


class AnacondaContentsManager(AsyncLargeFileManager):
    """
    A custom contents manager for JupyterLab that extends AsyncLargeFileManager.

    This manager hides the specified `anaconda_projects` directory from the root
    listing and prevents saving files or directories directly within this directory.
    """

    async def get(self, path: str, content=True, type=None, format=None) -> dict:  # noqa: FBT002, A002
        """
        Retrieve the content of the specified path.

        Args:
            path (str): The path to the file or directory, relative to the user's home directory.
            content (bool, optional): Whether to include the content of the file or directory. Defaults to True.
            type (str, optional): The type of the file or directory. Defaults to None.
            format (str, optional): The format of the file or directory. Defaults to None.

        Returns:
            dict: A dictionary representing the file or directory content, with the Anaconda projects directory hidden
            from the root listing if applicable.
        """
        files: dict = await super().get(path, content, type, format)
        contents = files.get("content", None)

        # hide `anaconda_projects` directory from root
        # GET / implies path=""
        if ANACONDA_PROJECTS_DIR and isinstance(contents, list):
            files["content"] = [content for content in contents if content.get("name", None) != ANACONDA_PROJECTS_DIR]

        return files

    async def save(self, model: dict, path="") -> dict:
        """
        Save a file or directory at the specified path but prevent the user to write on `anaconda_projects` directory.

        Args:
            model (dict): The model representing the file or directory to be saved.
            path (str, optional): The path where the file or directory will be saved. Defaults to an empty string.

        Returns:
            dict: A dictionary representing the saved file or directory.

        Raises:
            HTTPError: If an attempt is made to save directly within the `anaconda_projects` directory.
        """
        # Consider matching all content within /{ANACONDA_PROJECTS_DIR} in the future (implies removing all calls
        # to the contents-manager from v4/lib/toolbox-components and possibly other locations)
        # if ANACONDA_PROJECTS_DIR and path.startswith(f"/{ANACONDA_PROJECTS_DIR}"):

        # NOTE: For now only match direct path ($ANACONDA_PROJECTS_DIR)
        if ANACONDA_PROJECTS_DIR and path == f"/{ANACONDA_PROJECTS_DIR}":
            os_path = self._get_os_path(path)
            raise web.HTTPError(400, f"Cannot create file or directory {os_path!r}")

        return await super().save(model, path)

    async def rename_file(self, old_path: str, new_path: str) -> None:
        """
        Rename a file or directory at the specified path but prevent the user to write on `anaconda_projects` directory.

        Args:
            old_path (str): The current path of the file to be renamed.
            new_path (str): The destination path of the file to be renamed.

        Returns:
            None

        Raises:
            HTTPError: If an attempt is made to rename directly within the `anaconda_projects` directory.
        """
        # Consider matching all content within /{ANACONDA_PROJECTS_DIR} in the future (implies removing all calls
        # to the contents-manager from v4/lib/toolbox-components and possibly other locations)
        # if ANACONDA_PROJECTS_DIR and (
        #     old_path.startswith(ANACONDA_PROJECTS_DIR) or new_path.startswith(ANACONDA_PROJECTS_DIR)
        # ):

        # NOTE: For now only match direct path ($ANACONDA_PROJECTS_DIR)
        if ANACONDA_PROJECTS_DIR and ANACONDA_PROJECTS_DIR in (old_path, new_path):
            new_os_path = self._get_os_path(new_path)
            raise web.HTTPError(400, f"Cannot create file or directory {new_os_path!r}")

        return await super().rename_file(old_path, new_path)

    async def delete_file(self, path: str) -> None:
        """
        Delete a file or directory at the specified path but prevent the user to delete `anaconda_projects` directory.

        Args:
            path (str): The current path of the file to be deleted.

        Returns:
            None

        Raises:
            HTTPError: If an attempt is made to delete the `anaconda_projects` directory.
        """
        # Consider matching all content within /{ANACONDA_PROJECTS_DIR} in the future (implies removing all calls
        # to the contents-manager from v4/lib/toolbox-components and possibly other locations)
        # if ANACONDA_PROJECTS_DIR and path.startswith(f"/{ANACONDA_PROJECTS_DIR}"):

        # NOTE: For now only match direct path ($ANACONDA_PROJECTS_DIR)
        if ANACONDA_PROJECTS_DIR and path == ANACONDA_PROJECTS_DIR:
            raise web.HTTPError(403, f"Permission denied: {path}")

        return await super().delete_file(path)
